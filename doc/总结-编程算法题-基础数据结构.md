[TOC]

# 1. 数组和矩阵

**&& 其他数组问题**

**无重复排序数组中元素的范围段**

228.Summary Ranges

```java
public List<String> summaryRanges(int[] nums) {
    List<String> res = new ArrayList<>();
    if (nums.length == 0)  {
        return res;
    }
    int begin = nums[0], end = nums[0];
    Arrays.sort(nums);
    for (int i = 1; i < nums.length; i ++) {       
        if (nums[i] == nums[i - 1] + 1) {    // continue
            end = nums[i];
        } else {
            res.add(geneRange(nums, begin, end));
            begin = nums[i];
            end = nums[i];
        }
    }
    res.add(geneRange(nums, begin, end));     // handle tail
    return res;
}

private String geneRange(int[] nums, int begin, int end) {
    if (begin == end) {
        return "" + begin;
    }
    return begin + "->" + end;
}
```



**&& 数组元素为符合某种特征的数**

**错误的数字**

645. Set Mismatch

```java
public int[] findErrorNums(int[] nums) {
    for (int i = 0; i < nums.length; i ++) {
        while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) {   
            swap(nums, i, nums[i] - 1);
        }
    }
    for (int i = 0; i < nums.length; i ++) {
        if (nums[i] != i + 1) {
            return new int[]{nums[i], i + 1};
        }
    }
    return null;
}
```



**排序数组中删除重复的值**

[26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

```html
Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.
```

```java
public int removeDuplicates(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    if (nums.length == 1) return 1;

    int k = 0;
    for (int i = 0; i < nums.length; i ++) {
        if (i == 0 || nums[i] != nums[i - 1])  
            nums[k ++] = nums[i];
    }
    return k;
}
```



**数组中删除给定的值**

[27. Remove Element](https://leetcode.com/problems/remove-element/description/)

```java
public int removeElement(int[] nums, int val) {
    int k = 0;
    for (int i = 0; i < nums.length; i ++)
        if (nums[i] != val)                     
            nums[k ++] = nums[i];
    return k;
}
```



**排序数组中删除相同的元素，允许相同元素最多出现两次**

```html
Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

Given nums = [0,0,1,1,1,1,2,3,3],
```

```java
public int removeDuplicates(int[] nums) {
    if (nums.length < 2) return nums.length;

    int k = 1;                 
    int count = 1;
    for (int i = 1; i < nums.length; i ++) {
        if (nums[i] != nums[i-1]) {
            nums[k ++] = nums[i];
            count = 1;
        } else {                    // excepted
            if (count < 2)
                nums[k ++] = nums[i];
            count ++;
        }
    }
    return k;
}
```



**数组中的主元素**

[169. Majority Element](https://leetcode.com/problems/majority-element/)

```java
public int majorityElement(int[] nums) {
    int candidate = -1;
    int count = 0;
    for (int num : nums) {
        if (count == 0) {    
            count = 1;
            candidate = num;
            continue;
        }
        count = num == candidate ? ++ count : -- count;
    }
    return candidate;
}
```



**找出 n_3 的主元素**

```html
Input: [3,2,3]
Output: [3]
Example 2:

Input: [1,1,1,3,3,2,2,2]
Output: [1,2]
```

思路： 每次遍历的元素只能够更新 candidate1 | candidate2 的 counter,   
或者对 candidate 进行重新选取  
或者对两者的 counter 进行 -- 操作  

判断两个 candidate 在数组中出现的频次是否符合要求 

```java
public List<Integer> majorityElement(int[] nums) {
    List<Integer> res = new ArrayList<>();
    if (nums == null || nums.length == 0) return res;

    int candidate1 = nums[0], candidate2= nums[0];
    int count1 = 0, count2 = 0;    // iterate from 0 to len, need initialize as 0
    for (int num : nums) {     // must if
        if (num == candidate1)
            count1 ++;
        else if (num == candidate2)
            count2 ++;
        else if (count1 == 0) {           // need to reset
            candidate1 = num;
            count1 = 1;
        } else if (count2 == 0) {
            candidate2 = num;
            count2 = 1;
        } else {
            count1 --;
            count2 --;
        }
    }

    count1 = count2 = 0;           // find candidate frequency
    for (int num : nums) {
        if (num == candidate1)
            count1 ++;
        else if (num == candidate2)
            count2 ++;
    }
    if (count1 > nums.length/3) res.add(candidate1);
    if (count2 > nums.length/3) res.add(candidate2);
    return res;
}
```



**构建乘积数组**

[238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self)

```html
Input:  [1,2,3,4]
Output: [24,12,8,6]
Note: Please solve it without division and in O(n).
```

```java
public int[] productExceptSelf(int[] nums) {
    int n = nums.length;
    int[] product = new int[n];
    Arrays.fill(product, 1);
    int left = 1;
    for (int i = 1; i < n; i ++) {
        left *= nums[i-1];
        product[i] = left;
    }
    int right = 1;
    for (int i = n-2; i >= 0; i --) {    // From [n-1] begin *
        right *= nums[i+1];
        product[i] *= right;            // left*right
    }
    return product;
}
```





**把数组中的 0 移到末尾**

[283. Move Zeroes](https://leetcode.com/problems/move-zeroes/description/)

```java
public void moveZeroes(int[] nums) {
    int k = 0;
    for (int i = 0; i < nums.length; i ++)
        if (nums[i] != 0)
            nums[k ++] = nums[i];
    Arrays.fill(nums, k, nums.length, 0);
}
```



### 双指针

**两数之和为给定数的位置**

[1. Two Sum](https://leetcode.com/problems/two-sum/description/)

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> valIdxMap = new HashMap<>();
    for (int i = 0; i < nums.length; i ++) {
        if (valIdxMap.containsKey(target - nums[i]))
            return new int[]{valIdxMap.get(target-nums[i]), i}; 
        valIdxMap.put(nums[i], i);
    }
    throw new IllegalStateException();
}
```



**容器中放入水的最大容量**

[11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/)

![img](assets/question_11.jpg)

```
Example:
Input: [1,8,6,2,5,4,8,3,7]
Output: 49
```

```java
public int maxArea(int[] height) {
    int i = 0, j = height.length - 1;
    int maxArea = Integer.MIN_VALUE;
    while (i < j) {
        int curArea = Math.min(height[i], height[j])  * (j - i);
        maxArea = Math.max(maxArea, curArea);
        if (height[i] < height[j])     // skip left part
            i ++;
        else             // skip down part
            j --;
    }
    return maxArea;
}
```





**有序数组两数和为给定值**

[167. Two Sum II - Input array is sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

```java
public int[] twoSum(int[] nums, int target) {
    int i = 0, j = nums.length - 1;
    while (i < j) {                   
        int sum = nums[i] + nums[j];
        if (sum == target) 
            return new int[]{i + 1, j + 1};  
        else if (sum < target)
            i ++;
        else
            j --;
    }
    throw new IllegalArgumentException();
}
```



### 元组问题

**3元组和为 0 的所有可能**

[15. 3Sum](https://leetcode.com/problems/3sum/)

```html
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution62 set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
思路： 处理重复问题, 注意循环边界
```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    if (nums.length < 3) return res;
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 2; i ++) {     
        if (i > 0 && nums[i] == nums[i -1]) continue;    
        int l = i + 1, r = nums.length - 1;         
        while (l < r) {
            if (l != i + 1 && nums[l] == nums[l-1]) {            
                l ++;
                continue;
            }
            if (r != nums.length - 1 && nums[r] == nums[r+1]) {    
                r --;
                continue;
            }
            int sum = nums[i] + nums[l] + nums[r];
            if (sum == 0)
                res.add(Arrays.asList(nums[i], nums[l ++], nums[r --]));    
            else if (sum > 0)
                r --;
            else
                l ++;
        }
    }
    return res;
}
```



### 排序

**排序颜色**

```java
public void sortColors(int[] nums) {
    int lt = -1, gt = nums.length;
    int i = 0;
    int pivot = 1;
    while (i < gt) {
        if (nums[i] == pivot) 
            i ++;
        else if (nums[i] < pivot) 
            swap(nums, i ++, ++ lt);
        else 
            swap(nums, i, -- gt);
    }
}
```



**归并两个排序数组**

[88.Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/)

```html
Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
```

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int i = m - 1, j = n - 1;
    for (int merge = m + n - 1; merge >= 0; merge--) {
        if (i < 0)
            nums1[merge] = nums2[j--];
        else if (j < 0)
            nums1[merge] = nums1[i--];
        else if (nums1[i] > nums2[j])
            nums1[merge] = nums1[i--];    // select big one
        else
            nums1[merge] = nums2[j--];
    }
}
```

### **子数组**

**最短的未排序的连续子数组**

581.Shortest Unsorted Continuous Subarray

```java
public int findUnsortedSubarray(int[] nums) {
    int[] aux = nums.clone();
    Arrays.sort(aux);

    int start = 0;            // find first not correct position
    while (start < nums.length && nums[start] == aux[start]) {
        start ++;
    }

    int end = nums.length - 1;    
    while (end > start && nums[end] == aux[end]) {  
        end --;
    }
    return end - start + 1;
}
```





**生成杨辉三角**

[118. Pascal's Triangle](https://leetcode.com/problems/pascals-triangle)

```

```





**获得帕斯卡三角形的指定行**

[119. Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/)

```html
Input: 3
Output: [1,3,3,1]
```

```java
public List<Integer> getRow(int rowIndex) {
    List<Integer> res = new ArrayList<>();
    for (int i = 0; i < rowIndex + 1; i ++) {
        res.add(1);   
        for (int j = i - 1; j > 0; j --) {    // no need to handle 0,i position
            res.set(j, res.get(j - 1) + res.get(j));
        }
    }
    return res;
}
```



**最大的乘积子数组**

[152. Maximum Product Subarray(medium)](<https://leetcode.com/problems/maximum-product-subarray/>)

```
Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
```

思路： 需要处理当前遍历的值为负数的情况，维护当前最大和最小相乘结果，随着结果而不断改变的, curMax, curMin 所对应的子数组元素数量可能不一致。

DP 问题的精简实现；

```java
public int maxProduct(int[] nums) {
    int N = nums.length;
    int maxProduct = nums[0];
    int curMax = nums[0], curMin = nums[0];   
    for (int i = 1; i < nums.length; i ++) {
        if (nums[i] < 0) {
            int t = curMax;
            curMax = curMin;
            curMin = t;                      
        }
        curMax = Math.max(curMax * nums[i], nums[i]);  // is or not continue
        curMin = Math.min(curMin * nums[i], nums[i]);
        maxProduct = Math.max(curMax, maxProduct);
    }
    return maxProduct;
}
```



**最短的正数子数组和为给定数**

[209. Minimum Size Subarray Sum(medium)](https://leetcode.com/problems/minimum-size-subarray-sum/)

```java
public int minSubArrayLen(int s, int[] nums) {
    int minLen = Integer.MAX_VALUE;     // record result
    int L = 0, R = -1;
    int winSum = 0;
    while (L < nums.length) {
        if (R + 1 < nums.length && winSum < s) {
            winSum += nums[++ R];
        } else {
            winSum -= nums[L ++];
        }
        if (winSum >= s) {
            minLen = Math.min(minLen, R - L + 1);
        }
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;           // need handle init value
}
```



**找出数组中最长的连续 1**

[485. Max Consecutive Ones(easy)](https://leetcode.com/problems/max-consecutive-ones/)

```java
public int findMaxConsecutiveOnes(int[] nums) {
    int maxLen = 0, curLen = 0;
    for (int num : nums) {
        curLen = num == 1 ? curLen + 1 : 0;  // judge
        maxLen = Math.max(maxLen, curLen);
    }
    return maxLen;
}
```



**连续子数组和等于给定数的数量**

[560. Subarray Sum Equals K(medium)](https://leetcode.com/problems/subarray-sum-equals-k/)

```java
public int subarraySum(int[] nums, int k) {     //
    Map<Integer, Integer> curSumCntMap = new HashMap<>();
    curSumCntMap.put(0, 1);

    int curSum = 0;
    int count = 0;
    for (int i = 0; i < nums.length; i ++) {
        curSum += nums[i];
        int key = curSum - k;
        if (curSumCntMap.containsKey(key)) {
            count += curSumCntMap.get(key);
        }
        curSumCntMap.put(curSum, curSumCntMap.getOrDefault(curSum, 0) + 1);
    }
    return count;
}
```







**找出子数组和最大的子数组**

[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

```html
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

```java
public int maxSubArray(int[] nums) {
    int preSum = nums[0];
    int maxSum = preSum;
    for (int i = 1; i < nums.length; i ++) {
        preSum = (preSum > 0) ? preSum + nums[i] : nums[i];   
        maxSum = Math.max(preSum, maxSum);
    }
    return maxSum;
}
```







### **子序列**

**最长的连续序列**

128. Longest Consecutive Sequence

```java
public int longestConsecutive(int[] nums) {
    int maxCount = 0;
    Set<Integer> set = Arrays.stream(nums).boxed().collect(Collectors.toSet());

    for (int num : nums) {
        int curCount = 1;
        int curNum = num;
        while (set.contains(++ curNum)) {
            curCount ++;
            set.remove(curNum);
        }
        curNum = num;
        while (set.contains(-- curNum)) {
            curCount ++;
            set.remove(curNum);                         // remove to prevent duplication calculation
        }
        maxCount = Math.max(maxCount, curCount);
    }
    return maxCount;
}
```





**&& 买股票问题**



**最合适时机购买和销售股票**

[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0)
        return 0;
    int curMin = prices[0];
    int maxProfit = 0;
    for (int i = 1; i < prices.length; i ++) {
        curMin = Math.min(curMin, prices[i]);
        maxProfit = Math.max(maxProfit, prices[i] - curMin);
    }
    return maxProfit;
}
```





**&& 杨辉三角形**

**生成帕斯卡三角形**

118. Pascal's Triangle

```java
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> res = new ArrayList<>();
    if (numRows == 0) return res;

    res.add(Arrays.asList(1));
    if (numRows == 1)
        return res;
    res.add(Arrays.asList(1,1));
    if (numRows == 2)
        return res;
    for (int i = 2; i < numRows; i ++) {
        List<Integer> preList = res.get(i-1);
        List<Integer> curList = new ArrayList<>();
        curList.add(1);
        for (int j = 1; j < i; j ++)
            curList.add(j, preList.get(j-1) + preList.get(j));  // add not set
        curList.add(i, 1);
        res.add(new ArrayList<>(curList));
    }
    return res;
}
```





**获得帕斯卡三角形的指定行**

[119. Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/)

```java
public List<Integer> getRow(int rowIndex) {
    List<Integer> res = new ArrayList<>();
    for (int i = 0; i < rowIndex + 1; i ++) {
        res.add(1);   // every time add one element
        for (int j = i - 1; j > 0; j --) {    // no need to handle 0,i position
            res.set(j, res.get(j - 1) + res.get(j));
        }
    }
    return res;
}
```











矩阵：

旋转矩阵

旋转图片

最小路径和

单词搜索



直方图的最大矩形

最大的矩阵





最大的乘积数组

主元素

除自身的乘积数组





& 1~n 问题

找出重复的数字

找出所有消失的数字









前序和后续遍历构建二叉树



CPU 任务调度







base_two_point_binary_search_sort_matrix__major_build_1_n_rotate





sub_array_sequency_









GOOD: 

旋转数组中查找给定数字，可以含有重复的元素



找出数组汇总重复的数字，数字在 [1, n] 之间  

元素范围在 0-n 之间，求丢失的一个数字





重复元素中 3 个数和为给定值的所有三元组



kth 问题：

在排序矩阵中中出 kth 最小的元素

两个排序链表组成的 Pair 中的 kth 元素



含重复元素的旋转数组中是否存在某个元素









找出子数组和最大的子数组



合并时间间隔



&& 常见的二维矩阵搜索问题

从左上角到右下角有多少条路径可以到达

从左上角到右下角最小的路径和

二维矩阵中单词的搜索







&& 基础的排列组合问题：

求解下一个排列；

集合的子集；









**&& 旋转数组的问题**

33. 旋转有序无重复数组中查找指定元素索引





### 矩阵问题

单词搜索；

最小路径和；





**重新构造矩阵**

[566. Reshape the Matrix](https://leetcode.com/problems/reshape-the-matrix/description/)

```html
Input:
nums =
[[1,2],
 [3,4]]
r = 1, c = 4
Output:
[[1,2,3,4]]

Input:
nums =
[[1,2],
 [3,4]]
r = 2, c = 4
Output:
[[1,2],
 [3,4]]
```

```java
public int[][] matrixReshape(int[][] nums, int r, int c) {
    int m = nums.length, n = nums[0].length;
    if (m*n != r*c) return nums;

    int[][] matrix = new int[r][c];
    int index = 0;
    for (int i = 0; i < r; i ++) {
        for (int j = 0; j < c; j ++) {
            matrix[i][j] = nums[index/n][index%n];   // one dimension use col to
            index ++;
        }
    }
    return matrix;
}
```



**合并时间间隔**

[56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

```html
Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

```java
public List<Interval> merge(List<Interval> intervals) {
    if (intervals.size() < 2) return intervals;
    List<Interval> res = new ArrayList<>();
    intervals.sort((o1, o2) -> Integer.compare(o1.start, o2.start));          // sort to greedy
    int start = intervals.get(0).start;    // record in global
    int end = intervals.get(0).end;
    for (Interval item : intervals) {
        if (item.start <= end) {        
            end = Math.max(end, item.end);

        } else {    
            res.add(new Interval(start, end));
            start = item.start;
            end = item.end;
        }
    }
    // NOTE: handle end
    res.add(new Interval(start, end));
    return res;
}
```



**将正方形矩阵顺时针旋转90°**

[48. Rotate Image](https://leetcode.com/problems/rotate-image)

```html
Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

```java
public void rotate(int[][] matrix) {
    int n = matrix.length;
    int up = 0, left = 0, bottom = n -1, right = n - 1;
    while (left < right)     // only one element not need rotate
        rotateEdge(matrix, up ++, left ++, bottom --, right --);
}

// four point to rotate
private void rotateEdge(int[][] matrix, int up, int left, int bottom, int right) {
    int time = right - left;                 // rotate times
    for (int i = 0; i < time; i ++) {
        int t = matrix[up][left+i];
        matrix[up][left+i] = matrix[bottom-i][left];
        matrix[bottom-i][left] = matrix[bottom][right - i];
        matrix[bottom][right - i] = matrix[up+i][right];
        matrix[up+i][right] = t;
    }
}
```





**螺旋打印矩阵**

[54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix)

```html
Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

```java
public  ArrayList<Integer> printMatrix(int[][] m) {
    ArrayList<Integer> res = new ArrayList<>();
    if (m == null || m.length == 0) return res;

    int up = 0, left = 0, bottom = m.length - 1, right = m[0].length - 1;
    int layers = (Math.min(m.length, m[0].length) - 1) / 2 + 1;          // math ceil
    while (layers -- > 0)           // left <= right && up <= bottom
        visitEdge(m, up ++, left ++, bottom --, right --, res);
    return res;
}

private void visitEdge(int[][] m, int up, int left, int bottom, int right,  ArrayList<Integer> res) {
    if (left == right) {
        for (int i = up; i <= bottom; i ++)
            res.add(m[i][left]);
        return;
    }
    if (up == bottom) {
        for (int i = left; i <= right; i ++)
            res.add(m[up][i]);
        return;
    }
    // →
    for (int i = left; i < right; i ++)
        res.add(m[up][i]);
    // ↓
    for (int i = up; i < bottom; i ++)
        res.add(m[i][right]);
    // ←
    for (int i = right; i > left; i --)
        res.add(m[bottom][i]);
    // ↑
    for (int i = bottom; i > up; i --)
        res.add(m[i][left]);
}
```





**螺旋填充矩阵**

[59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)

```html
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
```

```java
int sequencer;
public int[][] generateMatrix(int n) {
    int[][] matrix = new int[n][n];
    sequencer = 1;
    int left = 0, up = 0, right = n -1, down = n - 1;
    while (left <= right)
        fillEdge(matrix, left ++, up ++, right --, down --);
    return matrix;
}

// note: direction  {--, ++}
//       extreme condition
private void fillEdge(int[][] matrix, int left, int up, int right, int down) {
    if (left == right) {
        matrix[left][up] = sequencer ++;
        return;
    }
    for (int i = left; i < right; i ++)
        matrix[up][i] = sequencer ++;
    for (int i = up; i < down; i ++)
        matrix[i][right] = sequencer ++;
    for (int i = right; i > left; i --)
        matrix[down][i] = sequencer ++;
    for (int i = down; i > up; i --)
        matrix[i][left] = sequencer ++;
}
```



**数组表示字符串对其进行加一**

[66. Plus One](https://leetcode.com/problems/plus-one/)

```html
Input: [4,3,2,1]
Output: [4,3,2,2]
```

```java
public int[] plusOne(int[] digits) {
    for (int i = digits.length - 1; i >= 0; i --) {   // use array to express num, [n-1] is bit
        if (digits[i] < 9) {
            digits[i] ++;
            return digits;
        }
        digits[i] = 0;
    }
    int[] nums =  new int[digits.length+1];      // need carry
    nums[0] = 1;
    return nums;
}
```



**将矩阵中为 0 的行和列都设置成 0**

[73. Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)

```html
Input:
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output:
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

```java
public void setZeroes(int[][] matrix) {
    int m = matrix.length, n = matrix[0].length;
    boolean[] rows = new boolean[m];             // whatever row or col need to modify 0
    boolean[] cols = new boolean[n];
    for (int i = 0; i < m; i ++) {
        for (int j = 0; j < n; j ++) {
            if (matrix[i][j] == 0) {
                rows[i] = true;
                cols[j] = true;
            } 
        }
    }
    for (int i = 0; i < m; i ++) {
        for (int j = 0; j < n; j ++) {
            if (rows[i] || cols[j])       // narrow space
                matrix[i][j] = 0;
        }
    }
}
```











**矩阵从左上到右下共有多少可能的路径**

[62. Unique Paths](https://leetcode.com/problems/unique-paths/)

```java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i ++) {       // init [0][0] no need handle specially
        dp[i][0] = 1;
    }
    for (int j = 0; j < n; j ++) {
        dp[0][j] = 1;
    }
    for (int i = 1; i < m; i ++) {
        for (int j = 1; j < n; j ++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m - 1][n - 1];
}
```





**矩阵从左上到右下路径最小路径和**

[64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)

```java
public int minPathSum(int[][] grid) {
    int m = grid.length, n = grid[0].length;

    int[][] dp = new int[m][n];
    dp[0][0] = grid[0][0];
    for (int i = 1; i < m; i ++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    for (int j = 1; j < n; j ++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }
    for (int i = 1; i < m; i ++) {
        for (int j = 1; j < n; j ++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[m - 1][n - 1];
}
```





**矩阵中是否存在指定的单词**

[79. Word Search](https://leetcode.com/problems/word-search/description/)

```html
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
```

```java
public boolean exist(char[][] board, String word) {
    int rows = board.length;
    int cols = board[0].length;
    boolean[][] visited = new boolean[rows][cols];
    for (int i = 0; i < rows; i ++) {
        for (int j = 0; j < cols; j ++) {
            if (backtracking(board, i, j, rows, cols, word, 0, visited)) {
                return true;
            }
        }
    }
    return false;
}

private boolean backtracking(char[][] board, int r, int c, int rows, int cols, String word, int index, boolean[][] visited) {
    if (index == word.length())
        return true;
    if (r >= rows || r < 0 || c >= cols || c < 0 || visited[r][c] || board[r][c] != word.charAt(index))
        return false;
    visited[r][c] = true;
    boolean hasFound = backtracking(board, r - 1, c, rows, cols, word, index + 1, visited) ||
            backtracking(board, r, c + 1, rows, cols, word, index + 1, visited) ||
            backtracking(board, r + 1, c, rows, cols, word, index + 1, visited) ||
            backtracking(board, r, c - 1, rows, cols, word, index + 1, visited);
    if (!hasFound)
        visited[r][c] = false;
    return hasFound;
}
```





### 旋转数组

**数组旋转 k 位**

[189. Rotate Array](https://leetcode.com/problems/rotate-array/)

```html
Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
```

```java
public void rotate(int[] nums, int k) {
    if (nums.length == 1) return ;

    int n = nums.length;
    k = k % n;                     // prevent unnecessary rotate
    reverse(nums, 0, n-k-1);
    reverse(nums, n-k, n-1);
    reverse(nums, 0, n-1);
}
```





### 数组元素约束

**元素范围 0_n 数组中丢失的数字**

[268. Missing Number](https://leetcode.com/problems/missing-number)

```html
Input: [3,0,1]
Output: 2
Example 2:

Input: [9,6,4,2,3,5,7,0,1]
Output: 8
```

题目描述：数组元素在 0-n 之间，但是有一个数是缺失的，要求找到这个缺失的数。

A ^ A = 0
0 1 2 3 4 5 6    7 6 3 4 5 2    ...
手动构造重复的对 ^0-n
            ^[0]-[n-1]

```java
public int missingNumber(int[] nums) {
    int res = 0;
    for (int i = 0; i < nums.length; i ++) {
        res ^= i;                  // [0,n-1]
        res ^= nums[i];            // [0,n]
    }
    res ^= nums.length;
    return res;
}
```





**元素范围 1-n 找出所有消失的数**

[448. Find All Numbers Disappeared in an Array](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)

```java
public List<Integer> findDisappearedNumbers(int[] nums) {
    List<Integer> ret = new ArrayList<>();
    for (int i = 0; i < nums.length; i ++)
        while (nums[i] != i + 1 && nums[nums[i] - 1] != nums[i])
            swap(nums, i, nums[i] - 1);

    for (int i = 0; i < nums.length; i ++)
        if (nums[i] != i + 1)        // nums[i] is redundant
            ret.add(i + 1);          // disappear, not in slot
    return ret;
}
```





### 查找

**排序矩阵中找出出 kth 小的元素**

[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)

```html
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,
```

题目描述： 第 k 小的元素，非第 k 小的不同元素，每行与每列是递增的

思路一： 通过 堆来进行对应的顺序添加放入，保证插入的顺序即为对应的顺序

```java
public int kthSmallest(int[][] matrix, int k) {
    PriorityQueue<Tuple> pq = new PriorityQueue<>();
    int m = matrix.length, n = matrix[0].length;
    for (int i = 0; i < n; i ++)
        pq.offer(new Tuple(0, i, matrix[0][i]));

    for (int i = 0; i < k - 1; i ++) {
        Tuple t = pq.poll();
        if (t.x == m-1) continue;
        pq.offer(new Tuple(t.x + 1, t.y, matrix[t.x+1][t.y]));
    }
    return pq.peek().val;
}


class Tuple implements Comparable<Tuple> {
    int x, y;
    int val;

    Tuple(int x, int y, int val) {
        this.x = x;
        this.y = y;
        this.val = val;
    }

    public int compareTo(Tuple that) {
        return this.val - that.val;
    }
}
```

思路二： 二分查找实现

二分查找用于范围查询，相当于为每个数添加一个属性，小于等于该数的总个数

```java
public int kthSmallest(int[][] matrix, int k) {
    int m = matrix.length, n = matrix[0].length;
    int lo = matrix[0][0], hi = matrix[m-1][n-1];   // [lo,hi]
    while (lo <= hi) {
        int mid = lo + (hi-lo)/2;
        int cnt = countOfLessEqual(matrix, mid);
        if (cnt < k) 
            lo = mid + 1;
        else 
            hi = mid - 1;    // cnt=k kth in [lo,mid], and -1 to skip loop
    }
    return lo;
}

// <=mid
private int countOfLessEqual(int[][] matrix, int key) {
    int cnt = 0;
    for (int i = 0; i < matrix.length; i ++) {
        for (int j = 0; j < matrix[0].length; j ++) {
            if (matrix[i][j] <= key) cnt ++;
            else break;      // NOTE: use sorted property
        }
    }
    return cnt;
}
```





**<u>==&& 旋转数组上的查找==</u>**





**旋转有序无重复数组中查找指定元素索引**

[33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array)

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

```java
public int search(int[] nums, int target) {
    int smallestIndex = -1;
    int lo = 0, hi = nums.length - 1;
    while (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        if (nums[mid] < nums[hi])     // [mid] in R half,  smallest in R half
            hi = mid;
        else         // [mid] in L half, smallest in R half
            lo = mid + 1;
    }
    smallestIndex = lo;

    lo = 0;
    hi = nums.length - 1;
    while (lo <= hi) {         // binary search with offset
        int mid = lo + (hi - lo) / 2;
        int realMid = (mid + smallestIndex) % nums.length;   // add offset
        if (nums[realMid] == target)
            return realMid;
        else if (nums[realMid] < target)
            lo = mid + 1;
        else
            hi = mid - 1;
    }
    return -1;
}
```





**旋转有序含重复元素数组中判断是否存在某个值**

[81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)

```java
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:

Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
```



思路一： 找到含重复元素旋转数组中的旋转点，之后通过带偏移的二分查找进行查找。

```java
public boolean search(int[] nums, int target) {
    if (nums == null || nums.length == 0) return false;

    int firstIndex = getFirstIndex(nums);
    if (nums[nums.length-1] >= target) {
        int index = Arrays.binarySearch(nums, firstIndex, nums.length, target);
        return index >= 0;
    } else {
        int index = Arrays.binarySearch(nums, 0, firstIndex, target);
        return index >= 0;
    }
}

private int getFirstIndex(int[] nums) {
    int lo = 0, hi = nums.length - 1;
    while (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        if (nums[mid] == nums[lo] && nums[mid] == nums[hi])
            return getMinIndex(nums, lo, hi);
        if (nums[mid] <= nums[hi])
            hi = mid;   // [mid] in sub2, first int left half, first can be [mid]
        else
            lo = mid + 1;
    }
    return lo;
}

// case1: [1,1,3,1]
// case2: [1,1,0,1]
// case3: [1,1,1,1]
// NOTE: not find first element, is find first element index
private int getMinIndex(int[] nums, int lo, int hi) {
    for (int i = lo + 1; i < hi; i ++) {
        if (nums[i] == nums[lo])
            continue;
        else if (nums[i] < nums[lo]) {    // nums[lo] as excepted
            return i;
        } else if (nums[i] > nums[lo]) {
            for (int j = i + 1; j <= hi; j ++)    // find first equal [lo]
                if (nums[j] == nums[lo])
                    return j;
        }
    }
    return lo;
}
```

思路2： 不断在有序的某个段上进行判断之后查找，分析各种可能情况

```java
public boolean search(int[] nums, int target) {
    int start = 0, end = nums.length - 1, mid = -1;
    while(start <= end) {
        mid = (start + end) / 2;
        if (nums[mid] == target) {
            return true;
        }
        //If we know for sure right side is sorted or left side is unsorted
        if (nums[mid] < nums[end] || nums[mid] < nums[start]) {
            if (target > nums[mid] && target <= nums[end]) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
            //If we know for sure left side is sorted or right side is unsorted
        } else if (nums[mid] > nums[start] || nums[mid] > nums[end]) {
            if (target < nums[mid] && target >= nums[start]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
            //If we get here, that means nums[start] == nums[mid] == nums[end], then shifting out
            //any of the two sides won't change the result but can help remove duplicate from
            //consideration, here we just use end-- but left++ works too
        } else {
            end--;
        }
    }
    return false;
}
```





**在无序数组中找出重复的数，数组中的元素值在 1~n**

[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)

```
Input: [1,3,4,2,2]
Output: 2
Example 2:

Input: [3,1,3,4,2]
Output: 3
```
思路1： 鸽子洞原理
```java
public int findDuplicate(int[] nums) {
    int lo = 1, hi = nums.length - 1;                 // lo, hi mean value, then find count that in range in all array
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        int cnt = countOfLessEqual(nums, mid);
        if (cnt > mid)
            hi = mid - 1; // duplication in left half
        else
            lo = mid + 1;   // cnt=mid, mean in [lo,mid] have no duplication, duplication(key) in right [mid+1,lo]
    }
    return lo;
}

private int countOfLessEqual(int[] nums, int key) {    // find in all array
    int cnt = 0;
    for (int num : nums)
        if (num <= key)
            cnt ++;
    return cnt;
}
```

思路2： 1~n 的特性

```java
public int findDuplicate(int[] nums) {
    int[] aux = nums.clone();
    for (int i = 0; i < nums.length; i ++) {
        while (aux[i] != i+1) {
            if (aux[i] == aux[aux[i] - 1]) {
                return aux[i];
            }
            swap(aux, i, aux[i] - 1);
        }
    }
    return -1;
}

private void swap(int[] a, int i, int j) {
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
}
```











**排序数组中第一次和最后一次出现的位置**

[34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
```

思路一： 构建两个查找第一次出现和最后一次出现的二分查找算法

```java
// first occur index to reduce last search range
public int[] searchRange(int[] nums, int aim) {
    int first = binarySearchFirst(nums, 0, nums.length - 1, aim);
    if (first == -1) {
        return new int[]{-1, -1};
    }
    int last = binarySearchLast(nums, first, nums.length - 1, aim);   // reduce search range
    return new int[]{first, last};
}

private int binarySearchFirst(int[] nums, int L, int R, int key) {
    while (L <= R) {
        int mid = L + (R - L) / 2;
        if (nums[mid] == key) {
            if (mid == 0 || (mid > 0 && nums[mid-1] != nums[mid]))
                return mid;
            else
                R = mid - 1;
        } else if (nums[mid] < key)
            L = mid + 1;
        else
            R = mid - 1;
    }
    return -1;
}

private int binarySearchLast(int[] nums, int L, int R, int key) {
    while (L <= R) {
        int mid = L + (R - L) / 2;
        if (nums[mid] == key) {
            if (mid == nums.length-1 || nums[mid] != nums[mid + 1])
                return mid;
            else
                L = mid + 1;
        } else if (nums[mid] < key)
            L = mid + 1;
        else
            R = mid - 1;
    }
    return - 1;
}
```

思路二： 复用同一个方法逻辑，进行处理

```java
public int[] searchRange(int[] nums, int target) {
    int first = binarySearch(nums, target);
    int last = binarySearch(nums, target + 1) - 1;
    if (first == nums.length || nums[first] != target) {
        return new int[]{-1, -1};
    } else {
        return new int[]{first, Math.max(first, last)};
    }
}

private int binarySearch(int[] nums, int target) {
    int l = 0, h = nums.length; // 注意 h 的初始值
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= target) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```



**查找给定值应该插入的位置**

[35. Search Insert Position](https://leetcode.com/problems/search-insert-position/)

思路一： [a,b] 区间方式查找

```
public int searchInsert(int[] nums, int target) {
    int lo = 0, hi = nums.length - 1;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        if (target == nums[mid])
            return lo;
        else if (target > nums[mid])
            lo = mid + 1;
        else
            hi = mid - 1;
    }
    return lo;
}
```

思路2： [a, b) 区间方式查找

```java
public int searchInsert(int[] nums, int target) {
    int lo = 0, hi = nums.length;
    while (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        if (target > nums[mid])
            lo = mid + 1;
        else                    // target in left half section,   when key=[mid] ⇔ key is left half
            hi = mid;
    }
    return lo;
}
```







**在二维矩阵中判断是否存在给定数**

[74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)

```
Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false
```

题目描述： i 行元素大于 i+1 行元素，i 行元素从左到右递增，非精确性排序的矩阵。

```java
public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0) return false;

    int m = matrix.length, n = matrix[0].length;
    int r = 0, c = n - 1;
    while (r < m && c >= 0) {
        if (matrix[r][c] == target)
            return true;
        else if (matrix[r][c] < target)
            r ++;
        else
            c --;
    }
    return false;
}
```









[442. Find All Duplicates in an Array](https://leetcode.com/problems/find-all-duplicates-in-an-array/)

```
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
```

思路： 1~n 的特性

```java
public List<Integer> findDuplicates(int[] nums) {
    List<Integer> res = new ArrayList<>();
    for (int i = 0; i < nums.length; i ++) {
        while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1])
            swap(nums, i, nums[i] - 1);
    }
    for (int i = 0; i < nums.length; i ++)
        if (nums[i] != i + 1)
            res.add(nums[i]);
    return res;
}
```





### 其他

**两个已排序数组的中位数**

[4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

```
nums1 = [1, 3]
nums2 = [2]
The median is 2.0


nums1 = [1, 2]
nums2 = [3, 4]
The median is (2 + 3)/2 = 2.5
```

思路一： todo

```java
public double findMedianSortedArrays(int[] A, int[] B) {
    int m = A.length, n = B.length;
    int l = (m + n + 1) / 2;
    int r = (m + n + 2) / 2;
    return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0;
}

// [aL, len1)             [bL, len2)
public double getkth(int[] A, int aL, int[] B, int bL, int k) {
    if (aL > A.length - 1) return B[bL + k - 1];
    if (bL > B.length - 1) return A[aL + k - 1];
    if (k == 1) return Math.min(A[aL], B[bL]);

    int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE;
    if (aL + k/2 - 1 < A.length) aMid = A[aL + k/2 - 1];
    if (bL + k/2 - 1 < B.length) bMid = B[bL + k/2 - 1];

    if (aMid < bMid)
        return getkth(A, aL + k/2, B, bL,       k - k/2);// Check: aRight + bLeft
    else
        return getkth(A, aL,       B, bL + k/2, k - k/2);// Check: bRight + aLeft
}
```

# 2. 栈和队列

## 栈

动态性： 弹出几个，加入根据弹出逻辑形成的新的值；

单调栈，用来处理一些需要顺序性的问题，值存放的为对应的索引；

通过容量来控制最终的动态调整结果；、结构设计：

带有最小值的栈

使用两个栈实现队列

使用两个队列实现栈

设计带有最大值的队列









括号问题：

验证括号









栈特性：

用于递归

判断一个弹出序列是否为某一放入序列的弹出序列  
  

## 单调栈问题  
可循环查找下一个更大的元素  
  
  
  


**计算逆波兰表达式**

[150. Evaluate Reverse Polish Notation(medium)](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

```
Input: ["4", "13", "5", "/", "+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
```

题目描述：有效的运算符包括 `+`, `-`, `*`, `/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

```java
public int evalRPN(String[] tokens) {
    Stack<Integer> stack = new Stack<>();
    int num1 = 0, num2 = 0, val = 0;
    for (String str : tokens) {
        switch (str) {              // string as switch judge condition
            case "+":
                num1 = stack.pop();
                num2 = stack.pop();
                val = num2 + num1;
                stack.push(val);
                break;
            case "-":
                num1 = stack.pop();
                num2 = stack.pop();
                val = num2 - num1;
                stack.push(val);
                break;
            case "*":
                num1 = stack.pop();
                num2 = stack.pop();
                val = num2 * num1;
                stack.push(val);
                break;
            case "/":
                num1 = stack.pop();
                num2 = stack.pop();
                val = num2 / num1;   // div not meet commutative law   
                stack.push(val);
                break;
            default:
                stack.push(Integer.parseInt(str));
                break;
        }
    }
    if (stack.isEmpty())
        return val;
    else if (stack.size() == 1)  // only one element
        return stack.pop();
    else
        throw new IllegalArgumentException();
}
```



**丑数II**

[264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/)

```
Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
Note:
```

思路： 

```java
public int nthUglyNumber(int n) {

    int[] dp = new int[n];
    dp[0] = 1;
    int index2=0, index3=0, index5=0;     // index as index, not value
    for (int i = 1; i < n; i++) {
        // cur
        dp[i] = Math.min(dp[index2]*2, Math.min(dp[index3]*3, dp[index5]*5));
        while (dp[index2]*2 <=dp[i])
            index2 ++;
        while (dp[index3]*3 <= dp[i])
            index3 ++;
        while (dp[index5]*5 <= dp[i])
            index5 ++;
    }
    return dp[n-1];
}
```





**验证括号**

[20. Valid Parentheses(easy)](https://leetcode.com/problems/valid-parentheses/description/)

```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    for (char c : s.toCharArray()) {
        if (c == '(') stack.push(')');
        else if (c == '[') stack.push(']');
        else if (c == '{') stack.push('}');
        else {
            if (stack.isEmpty()) 
                return false;
            char top = stack.pop();
            if (top != c) 
                return false;
        }
    }
    return stack.isEmpty();  // capacity judge
}
```





**&& 处理内嵌的逻辑**

**窄化路径**

[71. Simplify Path(medium)](https://leetcode.com/problems/simplify-path/)

```
Input: "/../"
Output: "/"
Input: "/a/../../b/../c//.//"
Output: "/c"
```

```java
public String simplifyPath(String path) {
    String[] dirs = path.split("/+");
    Stack<String> s = new Stack<>();
    for (String dir : dirs) {
        if (dir.equals(".") || dir.equals("")){  // handle split ""
            continue;
        } else if (dir.equals("..")) {          // upper layer
            if (!s.isEmpty())
                s.pop();
        } else {
            s.push(dir);
        }
    }
    if (s.isEmpty())
        return "/";

    StringBuilder sb = new StringBuilder();
    while (!s.isEmpty())
        sb.insert(0, "/"+s.pop());
    return sb.toString();
}
```



**&& 单调栈相关问题**

**循环数组中比当前元素大的下一个元素** 

[503. Next Greater Element II (Medium)](https://leetcode.com/problems/next-greater-element-ii/description/)

```text
Input: [1,2,1]
Output: [2,-1,2]
可以循环
```

思路： 栈中从栈底到栈顶中存放元素索引的值为顺序递减的，即每次保证新插入的元素 [i] 为栈中元素最小的便保证了该结构语义。

★★☆

```java
public int[] nextGreaterElements(int[] nums) {
    int N = nums.length;
    nums = geneNewNums(nums);
    Stack<Integer> idxStack = new Stack<>();    // index
    int[] nexts = new int[N * 2];    // next
    Arrays.fill(nexts, -1);
    for (int i = 0; i < nums.length; i++) {    // 2N use for mocking loop
        while (!idxStack.isEmpty() && nums[i] > nums[idxStack.peek()]) {
            nexts[idxStack.pop()] = nums[i];
        }
        idxStack.push(i);
    }
    return Arrays.copyOfRange(nexts, 0, N);
}
private int[] geneNewNums(int[] nums) {
    int[] newNums = new int[nums.length * 2];
    int k = 0;
    for (int i = 0; i < nums.length; i ++) 
        newNums[k ++] = nums[i];
    for (int i = 0; i < nums.length; i ++) 
        newNums[k ++] = nums[i];
    return newNums;
}
```



**数组中元素与下一个比它大的元素之间的距离**

[739. Daily Temperatures (Medium)](https://leetcode.com/problems/daily-temperatures/description/)

```html
Input: [73, 74, 75, 71, 69, 72, 76, 73]
Output: [1, 1, 4, 2, 1, 1, 0, 0]
```

```java
public int[] dailyTemperatures(int[] T) {
    Stack<Integer> idxStack = new Stack<>();  // store index
    int[] dist = new int[T.length];           // distance
    for (int i = 0; i < T.length; i ++) {
        while (!idxStack.isEmpty() && T[i] > T[idxStack.peek()]) {
            int preIndex = idxStack.pop();     // 比当前值小的向右最近的元素索引
            dist[preIndex] = i - preIndex;
        }
        idxStack.push(i);
    }
    return dist;
}
```





**&& 处理嵌套问题**

**扁平嵌套列表迭代器**

[341. Flatten Nested List Iterator(Medium)](https://leetcode.com/problems/flatten-nested-list-iterator/)

```
Input: [[1,1],2,[1,1]]
Output: [1,1,2,1,1]

Input: [1,[4,[6]]]
Output: [1,4,6]
```

思路： 栈中保存各个嵌套的结果，逆序的放入，弹出的时候即为正序弹出；

```java
Stack<NestedInteger> stack = new Stack<>();

public NestedIterator(List<NestedInteger> nestedList) {
    for (int i = nestedList.size() - 1; i >= 0; i --) {
        stack.push(nestedList.get(i));
    }
}

@Override
public Integer next() {
    return stack.pop().getInteger();
}

@Override
public boolean hasNext() {
    while (!stack.isEmpty()) {  // iterate to find one integer
        NestedInteger cur = stack.peek();
        if (cur.isInteger())   // is or not nested
            return true;
        stack.pop();
        for (int i = cur.getList().size() - 1; i >= 0; i --) 
            stack.push(cur.getList().get(i));
    }
    return false;
}
```



**解码字符串**

[394. Decode String](https://leetcode.com/problems/decode-string/)

```
s = "3[a]2[bc]", return "aaabcbc".
s = "3[a2[c]]", return "accaccacc".
s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
```

思路： 通过 stack 来处理多层嵌套的问题，不断的添加与对弹出的内容进行处理之后再放入进行处理；区分数字和字母，两者表示不同的行为；

★★★

```java
public String decodeString(String s) {
    Stack<Integer> count = new Stack<>();
    Stack<String> result = new Stack<>();
    int i = 0;
    result.push("");
    while (i < s.length()) {
        char ch = s.charAt(i);
        if (ch >= '0' && ch <= '9') {     // count
            int start = i;
            while (s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '9') 
                i++;   // make i last digit 
            count.push(Integer.parseInt(s.substring(start, i + 1)));
        } else if (ch == '[') {
            result.push("");
        } else if (ch == ']') {
            // generate string
            String str = result.pop();
            StringBuilder sb = new StringBuilder();
            int times = count.pop();
            for (int j = 0; j < times; j ++) {
                sb.append(str);
            }
            result.push(result.pop() + sb.toString());
        } else {  // character
            result.push(result.pop() + ch);
        }
        i += 1;
    }
    return result.pop();
}
```
  
  
  




## 队列

**&& 图的 BFS 遍历寻找**

**最短单词路径** 

[127. Word Ladder (Medium)](https://leetcode.com/problems/word-ladder/description/)

```
Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
```

题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    wordList.add(beginWord);
    int N = wordList.size();
    int start = N - 1;
    int end = 0;
    while (end < N && !wordList.get(end).equals(endWord))
        end++;

    if (end == N)
        return 0;

    List<Integer>[] graphic = buildGraphic(wordList);
    return getShortestPath(graphic, start, end);
}

private List<Integer>[] buildGraphic(List<String> wordList) {
    int N = wordList.size();
    List<Integer>[] graphic = new List[N];
    for (int i = 0; i < N; i++) {
        graphic[i] = new ArrayList<>();
        for (int j = 0; j < N; j++) {
            if (isConnect(wordList.get(i), wordList.get(j))) {
                graphic[i].add(j);
            }
        }
    }
    return graphic;
}

private boolean isConnect(String s1, String s2) {
    int diffCnt = 0;
    for (int i = 0; i < s1.length(); i++) {    //  && diffCnt <= 1 
        if (s1.charAt(i) != s2.charAt(i)) {
            diffCnt++;
        }
    }
    return diffCnt == 1;
}

private int getShortestPath(List<Integer>[] graphic, int start, int end) {
    Queue<Integer> queue = new LinkedList<>();
    boolean[] visited = new boolean[graphic.length];
    queue.offer(start);
    visited[start] = true;
    int path = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        path++;
        while (size-- > 0) {
            int cur = queue.poll();
            for (int next : graphic[cur]) {
                if (next == end)   // found
                    return path;
                if (visited[next])
                    continue;
                visited[next] = true;
                queue.offer(next);
            }
        }
    }
    return 0;
}
```



## 优先队列

第 k 个元素

找出频次出现最高的 k 个数



滑动窗口的最大值

字符串解码

树的遍历

用于内部多次迭代：

扁平嵌套列表迭代器



遍历、设计、heap、parentheses

heap、nested、解码、

ugly



kth 问题：

出现频次最大的 k 个数；

两个排序数组中找出 k 个最小的数；

**数组中第 k 大的元素**

[215. Kth Largest Element in an Array(medium)](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)

```
Input: [3,2,1,5,6,4] and k = 2
Output: 5
```

思路一： 堆实现

```java
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    for (int num : nums) {
        pq.offer(num);
        if (pq.size() == k + 1)
            pq.poll();
    }
    return pq.peek();
}
```

思路二： 转换成 第 N-k 小问题，使用快速选择算法

```java
public int findKthLargest(int[] nums, int k) {
    int N = nums.length;
    int lo = 0, hi = N - 1;
    k = N - k;            // ==>   kthLowest
    while (lo < hi) {
        int j = partition(nums, lo, hi);
        if (j == k)
            return nums[k];
        else if (j < k)
            lo = j + 1;
        else
            hi = j - 1;
    }
    return nums[k];
}

public int partition(int[] nums, int lo, int hi) {
    int pivot = nums[lo];
    int i = lo, j = hi + 1;
    while (true) {
        while (nums[++ i] < pivot) if (i == hi) break;       
        while (nums[-- j] > pivot) if (j == lo) break;
        if (i >= j)
            break;
        swap(nums, i, j);
    }
    swap(nums, j, lo);
    return j;
}

private static void swap(int[] a, int i, int j) {
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
}
```



**滑动窗口的最大值**

[239. Sliding Window Maximum(hard)](https://leetcode.com/problems/sliding-window-maximum/)

```
Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

思路一： 通过 Deque 构建最大队列，队首的元素一直都是最大的，队尾的元素一定是整体最小的，且队列整体单调，从队首到队尾为递减的； 通过每次添加一个元素时，让其插入后为原来符合规则的结构中最小的即可；

之后是 queue 与 deque 处理有序中的删除情况，通过 sequence 来实现；

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    if (nums == null || nums.length == 0 || nums.length < k || k < 0) return new int[]{};

    MaxQueue maxQueue = new MaxQueue();
    int[] res = new int[nums.length - k];
    int index = 0;
    for (int i = 0; i < nums.length; i ++) {
        maxQueue.offer(nums[i]);
        if (maxQueue.size() == k) {
            res[index ++] = maxQueue.max();
            maxQueue.poll();
        }
    }
    return res;
}

class MaxQueue {
    Deque<Tuple> qmax      = new LinkedList<>();   
    Queue<Tuple> queue         = new LinkedList<>();
    int          sequencer = 0;

    public void offer(int val) {
        while (!qmax.isEmpty() && val >= qmax.peekLast().val)  
            qmax.pollLast();
        Tuple tuple = new Tuple(val, sequencer ++);
        queue.offer(tuple);
        qmax.offerLast(tuple);
    }

    public int poll() {
        if (queue.isEmpty())
            throw new NoSuchElementException();
        Tuple oldFront = queue.poll();
        if (qmax.peekFirst().index == oldFront.index)  
            qmax.pollFirst();
        return oldFront.val;
    }

    public int max() {
        if (queue.isEmpty())
            throw new NoSuchElementException();
        return qmax.peekFirst().val;
    }

    public int size() {
        return queue.size();
    }
}

class Tuple {
    int val;
    int index;

    Tuple(int val, int index) {
        this.val = val;
        this.index = index;
    }
}
```



**找出频次最高的 k 个数**

[347. Top K Frequent Elements(medium)](https://leetcode.com/problems/top-k-frequent-elements/)

思路一： 堆+Map 实现

todo pq 如何快速转换成 List 且每次都为最大数添加

★☆☆

```java
public List<Integer> topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> freqs = new HashMap<>();
    for (int num : nums)
        freqs.put(num, freqs.getOrDefault(num, 0) + 1);

    PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((o1,o2) -> o1.getValue() != o2.getValue() ? Integer.compare(o1.getValue(), o2.getValue()) : Integer.compare(o1.getKey(), o2.getKey()));
    for (Map.Entry<Integer, Integer> entry : freqs.entrySet()) {
        pq.offer(entry);
        if (pq.size() == k + 1)
            pq.poll();
    }
    List<Integer> res = new ArrayList<>();
    while (!pq.isEmpty())
        res.add(pq.poll().getKey());
    return res;
}
```

思路二： 排序 HashMap 成 LinkedHashMap 实现；之后只需要截取 LinkedHashMap 中前 k 个根据 Val 排序的 Key 即可。

```java
public List<Integer> topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> freqs = new HashMap<>();
    for (int num : nums)
        freqs.put(num, freqs.getOrDefault(num, 0) + 1);

    freqs = sortByValue(freqs);
    List<Integer> res = new ArrayList<>();
    for (Map.Entry<Integer, Integer> entry : freqs.entrySet()) {
        res.add(entry.getKey());
        if (res.size() == k)
            return res;
    }
    throw new IllegalArgumentException();
}

private Map<Integer, Integer> sortByValue(Map<Integer, Integer> map) {
    List<Map.Entry<Integer, Integer>> list = new ArrayList<>(map.entrySet());
    Collections.sort(list, (o1, o2) -> o1.getValue() != o2.getValue() ? Integer.compare(o2.getValue(), o1.getValue()) : Integer.compare(o1.getKey(), o2.getKey()));
    Map<Integer, Integer> newMap = new LinkedHashMap<>();
    for (Map.Entry<Integer, Integer> entry : list) {
        newMap.put(entry.getKey(), entry.getValue());
    }
    return newMap;
}
```

思路三： 桶排序

需要控制住正好为 k 个元素

```java
public List<Integer> topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> freqs = new HashMap<>();
    for (int val : nums)
        freqs.put(val, freqs.getOrDefault(val, 0) + 1);

    List<Integer>[] buckets = new ArrayList[nums.length + 1];
    for (Map.Entry<Integer, Integer> entry : freqs.entrySet()) {
        int freq = entry.getValue();
        if (buckets[freq] == null)
            buckets[freq] = new ArrayList<>();
        buckets[freq].add(entry.getKey());
    }

    List<Integer> topK = new ArrayList<>();
    for (int i = buckets.length - 1; i >= 0; i --) {
        if (buckets[i] == null) continue;
        if (topK.size() >= k) break;
        if (buckets[i].size() <= (k - topK.size()))
            topK.addAll(buckets[i]);
        else
            topK.addAll(buckets[i].subList(0, k - topK.size()));
    }
    return topK;
}
```



**&& 一定规则有序下**

**从两个排序链表中找出前 k 个最小的対**

[373. Find K Pairs with Smallest Sums(medium)](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)

```
Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [1,1],[1,1]
Explanation: The first 2 pairs are returned from the sequence:
             [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```

思路一： 通过<u>弹出最小，设法获得次小的方式实现</u>

处理 k 过大的情况， min{k, len1*len2}

```java
public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {
    List<int[]> res = new ArrayList<>();
    if(nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0 || k <= 0) 
        return res;

    PriorityQueue<Tuple> pq = new PriorityQueue<>((o1,o2) -> Integer.compare(o1.val, o2.val));
    int len1 = nums1.length, len2 = nums2.length;
    for (int i = 0; i < len2; i ++)                         
        pq.offer(new Tuple(0, i, nums1[0] + nums2[i]));

    for (int i = 0; i < Math.min(k, len1 * len2); i ++) {// k may too big
        Tuple t = pq.poll();
        res.add(new int[]{nums1[t.x], nums2[t.y]});
        if (t.x == len1 - 1) continue;
        pq.offer(new Tuple(t.x+1, t.y, nums1[t.x + 1] + nums2[t.y]));
    }
    return res;
}

public class Tuple {
    int x, y;
    int val;

    public Tuple(int x, int y, int val) {
        this.x = x;
        this.y = y;
        this.val = val;
    }
}
```

思路二： 穷举所有可能，之后对其进行排序实现；

```java
public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {
    List<int[]> res = new ArrayList<>();
    PriorityQueue<Tuple> pq = new PriorityQueue<>();
    for (int i = 0; i < nums1.length; i ++) {
        for (int j = 0; j < nums2.length; j ++)
            pq.offer(new Tuple(nums1[i], nums2[j]));
    }

    while (k -- > 0)
        if (!pq.isEmpty())
            res.add(new int[]{pq.peek().val1, pq.poll().val2});
    return res;
}

public class Tuple implements Comparable<Tuple> {
    int val1, val2;
    int sum;

    public Tuple(int x, int y) {
        this.val1 = x;
        this.val2 = y;
        this.sum = x + y;
    }

    @Override
    public int compareTo(Tuple that) {
        return this.sum - that.sum;
    }
}
```

# "结构" 问题
## 字符串问题

KMP-字符串匹配问题  
Manacher-回文串问题    
Trie 前缀树问题  
序列化问题, 保存值，树的序列化，用于构造，根据指定的字符串构造出指定的数据结构  
正则校验问题    
前缀问题  
      




API ：
- isLetter

- isLetterOrDigit

- toLowerCase

  包装类型进行比较的时候自动转换成基本类型比较 ???



StringBuilder
reverse
setCharAt



填充法统一处理 ：  # 增加串长度，统一 奇偶 的处理


## Hash 表问题

配合数组，进行统计词频、第一次、最后一次出现的位置、当前和的个数；

记录数组中 val -> index

配合 LinkedHashMap 实现根究 Value 排序并作为一个 Map 进行通用；

配合 PriorityQueue 实现不断地获取最大值；

配合 List 实现值对应多个 KEY 的应用场景；

配合 List ，在 Value 为 integer 时进行处理，如词频统计；



一对一的映射： 一个原来的节点对应一个拷贝的节点

构建一对一的映射表： 用于实现对称的一种结构

Hash 表配合滑动窗口实现，包含固定的窗口实现；

Hash 表用来去重，构建类似图形问题时，用于避免成环，形成无线循环；

存放连续的数据，通常用于求解最长的问题，最长的和谐序列、最长的连续数字等；

%%特殊的使用：

作为 DP 的动态规划表使用:

处理索引不为数字的类型，而直接为一个对象

337 问题记录抢房子的最大值

```
Map<Integer, Integer> valIdxMap;
Map<TreeNode, Integer> memo;
```



**&& 统计词频类问题**

**CPU 任务调度**

[621. Task Scheduler(Medium)](https://leetcode.com/problems/task-scheduler/)

```
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: A -> B -> idle -> A -> B -> idle -> A -> B.
```

统计词频，获取最大词频，获取为最大词频的总数

使用 PriorityQueue 来实现有序性

```java
 public int leastInterval(char[] tasks, int n) {
     Map<Character, Integer> freqs = new HashMap<>();
     for (int i = 0; i < tasks.length; i++) {
         freqs.put(tasks[i], freqs.getOrDefault(tasks[i], 0) + 1);
     }

     PriorityQueue<Map.Entry<Character, Integer>> maxHeap = new PriorityQueue<>((o1, o2) -> o1.getValue() != o2.getValue() ? Integer.compare(o2.getValue(), o1.getValue()) : Integer.compare(o1.getKey(), o2.getKey()));    // NOTE: maxHeap
     maxHeap.addAll(freqs.entrySet());           // use for Entry to control

     int maxFreq = maxHeap.peek().getValue();
     int count = 0;
     while (!maxHeap.isEmpty() && maxHeap.peek().getValue() == maxFreq) {
         count ++;
         maxHeap.poll();
     }

     return Math.max(tasks.length, (maxFreq - 1) * (n + 1) + count);
 }
```

使用 LinkedList 来实现有序性

```java
public int leastInterval(char[] tasks, int n) {
    Map<Character, Integer> freqs = new HashMap<>();
    for (int i = 0; i < tasks.length; i++) {
        freqs.put(tasks[i], freqs.getOrDefault(tasks[i], 0) + 1);
    }

    freqs = sortByValue(freqs);
    int maxFreq = freqs.entrySet().iterator().next().getValue();
    int count = 0;
    for (Map.Entry<Character, Integer> entry : freqs.entrySet()) {
        if (entry.getValue() == maxFreq) {
            count ++;
        } else {
            break;
        }
    }
    return Math.max(tasks.length, (maxFreq - 1) * (n + 1) + count);
}

private Map<Character, Integer> sortByValue(Map<Character, Integer> map) {
    List<Map.Entry<Character, Integer>> list = new ArrayList<>(map.entrySet());
    Collections.sort(list, (o1, o2) -> o1.getValue() != o2.getValue() ? Integer.compare(o2.getValue(), o1.getValue()) : Character.compare(o1.getKey(), o2.getKey()));
    Map<Character, Integer> newMap = new LinkedHashMap<>();
    for (Map.Entry<Character, Integer> entry : list) {
        newMap.put(entry.getKey(), entry.getValue());
    }
    return newMap;
}
```



**数组中在 k 范围差内是否有相同的数**

[219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/description/)

```
Example 1:
Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:
Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:
Input: nums = [1,2,3,1,2,3], k = 2
Output: false
```

描述： 

思路： 维护动态的一个记录表，此动态记录表中存放的是 [i-k-1, i]  之间的唯一数字，注意约束；

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    if (nums == null || nums.length <= 1)
        return false;
    if (k <= 0)
        return false;

    Set<Integer> record = new HashSet<>();  // fixed capacity k
    for (int i = 0; i < nums.length; i ++) {
        if (record.contains(nums[i]))  // NOTE: ∃x, x==nums[i]
            return true;
        record.add(nums[i]);  // init and strategy
        if (record.size() == k + 1) // fixed capacity
            record.remove(nums[i - k]);
    }
    return false;
}
```



**在 k 索引范围内两数是否有小于等于 t**

[220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/description/)

```java
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    TreeSet<Long> record = new TreeSet<>();
    for (int i = 0; i < nums.length; i ++) {
        if (record.ceiling( (long) nums[i] - (long) t) != null &&      // NOTE: [i]-t=<x<=[i]+t, x∈record
                record.ceiling((long) nums[i] - (long) t) <= (long) nums[i] + (long) t) 
            return true;
        record.add((long) nums[i]);
        if (record.size() == k + 1)
            record.remove((long) nums[i - k]);
    }
    return false;
}
```



**找出两个数组中重合的数**

[349. Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/description/)

```java
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
```

思路一： 动态维护 Set，在使用完一次后便删除

```java
public int[] intersection(int[] nums1, int[] nums2) {
    Set<Integer> set = new HashSet<>();
    for (int num : nums1)      // init map set
        set.add(num);
    ArrayList<Integer> list = new ArrayList<>();
    for (int num : nums2) {
        if (set.contains(num)) {   // ∃, remove
            list.add(num);
            set.remove(num);
        }
    }
    return list.stream().mapToInt(Integer::valueOf).toArray();
}
```



思路二： 排序 + 双指针；

Set 只有在两个数组有相同数据的情况下进行记录，同时排除掉对应的重复数据；

```java
public int[] intersection(int[] nums1, int[] nums2) {
    Set<Integer> set = new HashSet<>();
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    int i = 0, j = 0;
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] == nums2[j]) {
            set.add(nums1[i]);                 // handle duplicated element
            i ++;
            j ++;
        }
        else if (nums1[i] < nums2[j])
            i ++;
        else
            j ++;
    }
    int[] res = new int[set.size()];
    int k = 0;
    for (Integer val : set)
        res[k ++] = val;
    return res;
}
```



**两个数组相同的数，可重复**

[350. Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/description/)

```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
```

思路一： 统计词频，使用一次减一次词频，使用完毕进行删除的一个 hash 表；

```java
public int[] intersect(int[] nums1, int[] nums2) {

    Map<Integer, Integer> freqs = new HashMap<>();
    for (int num : nums1)
        freqs.put(num, freqs.getOrDefault(num, 0) + 1);

    List<Integer> res = new ArrayList<>();
    for (int num : nums2) {               
        if (freqs.containsKey(num)) {    // have token can use
            res.add(num);
            freqs.put(num, freqs.get(num) - 1);
            if (freqs.get(num) == 0)
                freqs.remove(num);   // this element not have in all
        }
    }
    return res.stream().mapToInt(Integer::intValue).toArray();
}
```

思路二： 通过 List 来作为查找表，查找为 O(n)，效率低

```java
public int[] intersect(int[] nums1, int[] nums2) {
    List<Integer> record = new ArrayList<>();    // every element record
    List<Integer> res = new ArrayList<>();
    for (int num : nums1)  // init record list
        record.add(num);

    for (int num : nums2) {             // ∃, remove
        if (record.contains(num)) {
            res.add(num);
            record.remove(Integer.valueOf(num));  // convert to value to remove
        }
    }
    return res.stream().mapToInt(Integer::valueOf).toArray();
}
```



**三点之间距离相等的个数**

[447. Number of Boomerangs](https://leetcode.com/problems/number-of-boomerangs/description/)

```java
 Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k)
 such that the distance between i and j equals the distance between i and k (the order of the tuple matters).

Find the number of boomerangs.
 You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).

Example:
Input:
[[0,0],[1,0],[2,0]]

Output:
2

Explanation:
The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]
```

思路一： 对于当前遍历的点，为其构建一张 hash 表，作为一个属性，记录其可以到达的距离，以及到达该距离可能点的个数；

```java
public int numberOfBoomerangs(int[][] points) {
    int res = 0;
    for (int i = 0; i < points.length; i ++) {
        Map<Integer, Integer> record = new HashMap<>();   
        for (int j = 0; j < points.length; j ++) {
            if (j != i) {
                int distance = distance(points[i], points[j]);
                record.put(distance, record.getOrDefault(distance, 0) + 1);   
            }
        }
   
        for (int key : record.keySet())  
            if (record.get(key) >= 2)
                res += record.get(key) * (record.get(key) - 1);    
    }
    return res;
}

private int distance(int[] A, int[] B) {
    return (A[0] - B[0]) * (A[0] - B[0]) + (A[1] - B[1]) * (A[1] - B[1]);
}
```





**四个数相加为0 的个数**

[454. 4Sum II](https://leetcode.com/problems/4sum-ii/description/)

```java
Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```

思路： 对于 {C, D} 成为一个结构，使其具备两者和为某个数的频率属性，之后统计 {A, B} 结构时借助 {C, D} 的属性；

```java
public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
    Map<Integer, Integer> recordCD = new HashMap<>();
    for (int i = 0; i < C.length; i ++) {
        for (int j = 0; j < D.length; j ++) {
            int key = C[i] + D[j];
            recordCD.put(key, recordCD.getOrDefault(key, 0) + 1);
        }
    }
    int res = 0;
    for (int i = 0; i < A.length; i ++) {
        for (int j = 0; j < B.length; j ++) {
            int key = 0 - A[i] - B[j];
            if (recordCD.containsKey(key))    
                res += recordCD.get(key);
        }
    }
    return res;
}
```



**三数和最接近目标数的和**

[16. 3Sum Closest](https://leetcode.com/problems/3sum-closest/)

```
Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
```

思路： 跳过重复元素进行加速搜索，在找到完全等于自身即最近时直接返回；

```java
public int threeSumClosest(int[] nums, int target) {
    int res = nums[0] + nums[1] + nums[nums.length - 1];    // initialization
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 2; i ++) {
        if (i > 0 && nums[i] == nums[i - 1])
            continue;
        int l = i + 1, r = nums.length - 1;
        while (l < r) {
            int sum = nums[i] + nums[l] + nums[r];
            if (sum > target) {
                while (l < r && nums[r] == nums[r - 1]) r --;     // find last duplicated element
                r --;               // find first element not duplicated
            }
            else  {
                while (l < r && nums[l] == nums[l+1]) l ++;
                l ++;
            }
            if (Math.abs(sum - target) < Math.abs(res - target)) {
                res = sum;
                if (res - target == 0) return res;     // skip loop in advance
            }
        }
    }
    return res;
}
```



**数组中四数和为给定数的所有不同的组**

```
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution15 set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```

思路一： 排序+去重+双指针实现；

```java
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> res = new ArrayList<>();
    int N = nums.length;
    Arrays.sort(nums);
    for (int i = 0; i < N - 3; i ++) {
        if (i > 0 && nums[i] == nums[i - 1])      // prevent duplication
            continue;
        for (int j = i + 1; j < N - 2; j ++) {
            if (j > i + 1 && nums[j] == nums[j - 1])   // prevent duplication
                continue;
            int p = j + 1, q = N - 1;
            while (p < q) {
                int sum = nums[i] + nums[j] + nums[p] + nums[q];
                if (sum > target)
                    q --;
                else if (sum < target)
                    p ++;
                else {
                    res.add(Arrays.asList(nums[i], nums[j], nums[p], nums[q]));
                    while (p < q && nums[p] == nums[p + 1]) p ++;    // skip duplication
                    while (p < q && nums[q] == nums[q - 1]) q --;
                    p ++;
                    q --;
                }
            }
        }
    }
    return res;
}
```

思路二： hash 表实现

todo



**判断一个数字是否是快乐数字**

[202. Happy Number](https://leetcode.com/problems/happy-number/)

```
Input: 19
Output: true
Explanation:
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

描述： 每一位数字的平方和相加为一个数，之后对求出的数执行同样的逻辑，知道得到的数为 1；

思路： 通过 record 记录每次产生的结果，当出现重复的结果时，直接退出，未重复则继续；

```java
public boolean isHappy(int n) {
    int cur = n;
    Set<Integer> record = new HashSet<>();     // record to prevent loop
    while (cur != 1) {
        cur = getDigitSquare(cur);
        if (!record.contains(cur))
            record.add(cur);
        else           // in this have loop
            return false;
    }
    return true;
}

private int getDigitSquare(int n) {
    int sum = 0;
    while (n > 0) {
        int digit = n % 10;
        sum += digit * digit;
        n = n / 10;
    }
    return sum;
}
```









**&& 基本应用**



**判断字符串同构**

[205. Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/)

```
Input: s = "egg", t = "add"
Output: true

Input: s = "foo", t = "bar"
Output: false

Input: s = "paper", t = "title"
Output: true
```

整体为一对一映射问题，通过 hash 表实现该数据结构即可

思路一： 记录每个字符出现的位置，比较两个对应的字符出现位置，只有对应字符出现位置才能进一步向下寻找；

```java
public boolean isIsomorphic(String s, String t) {
    if (s.length() != t.length())
        return false;
    int[] hash1 = new int[256];      // record position as unique identifier
    int[] hash2 = new int[256];
    for (int i = 0; i < s.length(); i ++) {
        if (hash1[s.charAt(i)] != hash2[t.charAt(i)])
            return false;
        hash1[s.charAt(i)] = i + 1;
        hash2[t.charAt(i)] = i + 1;
    }
    return true;
}
```

思路二： 通过对 value List 的查找来实现，复杂度 O(N)

```
public boolean isIsomorphic(String s, String t) {
    if (s.length() != t.length())
        return false;
    Map<Character, Character> record = new HashMap<>();
    for (int i = 0; i < s.length(); i ++) {
        if (record.containsKey(s.charAt(i))) {
            if (record.get(s.charAt(i)) != t.charAt(i))
                return false;
        } else {
            if (record.containsValue(t.charAt(i)))
                return false;
            record.put(s.charAt(i), t.charAt(i));
        }
    }
    return true;
}
```



**判断两个字符是否是变位词**

[242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)

```
Input: s = "anagram", t = "nagaram"
Output: true

Input: s = "rat", t = "car"
Output: false

Note:
You may assume the string contains only lowercase alphabets.
```

思路一： 统计原始词频，与带匹配的字符进行对应的减词频，类似某个桶中可用的 token 数量；

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length())
        return false;
    int[] freqs = new int[26];
    for (char c : s.toCharArray())
        freqs[c-'a'] ++;
    for (char c : t.toCharArray())
        if (-- freqs[c-'a'] < 0)
            return false;
    return true;
}
```

思路二： 排序比较

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length())
        return false;
    return sort(s).equals(sort(t));
}

private String sort(String s) {
    char[] chs = s.toCharArray();
    Arrays.sort(chs);
    return new String(chs);
}
```



**判断单词是否与指定模式匹配**

[290. Word Pattern](https://leetcode.com/problems/word-pattern/)

```
Input: pattern = "abba", str = "dog cat cat dog"
Output: true
Example 2:

Input:pattern = "abba", str = "dog cat cat fish"
Output: false
```

思路： 与。。。

```java
public boolean wordPattern(String pattern, String str) {
    String[] words = str.split(" ");
    if (pattern.length() != words.length)
        return false;
    Map<Character, Integer> map1 = new HashMap<>();
    Map<String, Integer> map2 = new HashMap<>();
    for (Integer i = 0; i < pattern.length(); i ++) {            // why `Integer`,  `int` can not
        if (map1.put(pattern.charAt(i), i) != map2.put(words[i], i))
            return false;
    }
    return true;
}
```



**根据词频排序字符**

[451. Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency/)

```
Input:
"Aabb"

Output:
"bbAa"
```

思路一： 统计词频，根据传入字符串构建对应的桶容量，将对应词频的桶中放入对应词频的数字；

通过 chs 字符数组进行最终结果的返回，赋值开销更小，效率比拼接更高；

```java
public String frequencySort(String s) {
    Map<Character, Integer> freqs = new HashMap<>();
    for (char c : s.toCharArray())
        freqs.put(c, freqs.getOrDefault(c, 0) + 1);

    List<Character>[] buckets = new ArrayList[s.length() + 1];
    for (char key : freqs.keySet()) {
        int freq = freqs.get(key);
        if (buckets[freq] == null)
            buckets[freq] = new ArrayList<>();
        buckets[freq].add(key);
    }

    char[] chs = s.toCharArray();
    int k = 0;
    for (int freq = buckets.length - 1; freq > 0; freq --) {
        if (buckets[freq] == null) continue;
        for (char val : buckets[freq]) {
            for (int i = 0; i < freq; i ++)
                chs[k ++] = val;
        }
    }
    return new String(chs);
}
```



**最长和谐序列**

描述： 和谐序列中最大数和最小数之差正好为 1，应该注意的是序列的元素不一定是数组的连续元素

[594. Longest Harmonious Subsequence](https://leetcode.com/problems/longest-harmonious-subsequence/)

```java
public int findLHS(int[] nums) {
    Map<Integer, Integer> freqs = new HashMap<>();
    for (int num : nums)
        freqs.put(num, freqs.getOrDefault(num, 0) + 1);

    int longest = 0;
    for (Map.Entry<Integer, Integer> entry : freqs.entrySet()) {
        if (freqs.containsKey(entry.getKey() + 1)) {
            longest = Math.max(longest, entry.getValue() + freqs.get(entry.getKey() + 1));
        }
    }
    return longest;
}
```


## 滑动窗口问题

**最下给定和为 s 的子数组**

209.Minimum Size Subarray Sum



```java
public int minSubArrayLen(int s, int[] nums) {
    int minLen = Integer.MAX_VALUE;     // record result
    int L = 0, R = -1;
    int winSum = 0;
    while (L < nums.length) {
        if (R + 1 < nums.length && winSum < s) {
            winSum += nums[R + 1];
            R ++;   // [R] in window
        } else {
            winSum -= nums[L];
            L ++;                  // sliding window only can move right
        }
        if (winSum >= s) {
            minLen = Math.min(minLen, R - L + 1);
        }
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;           // need handle init value
}
```
