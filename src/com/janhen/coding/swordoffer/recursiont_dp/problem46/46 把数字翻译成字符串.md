// 46 把数字翻译成字符串
//https://leetcode.com/problems/decode-ways/description/

给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”... 26 翻译成“z”。一个数字有多种翻译可能，
例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。

```
给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”... 25 翻译成“z”。  
一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。  
实现一个函数，用来计算一个数字有多少种不同的翻译方法。  
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

## 思路1
f(i) : 从第 i 位数字开始的不同翻译的数目
g(i, i+1) : 第 i 和第 i+1 位数字拼接是否在 [10, 25] 之间

> f(i + 1) + g(i, i + 1) * f(i + 2)   ; i ∈ [0, len - 3]  
> f(i)  =   f(i+1) + g(i, i+1) * 1 ;     i = len - 2  即后两位数字的情况  
>             1 ;  i = len -1 即最后一位数字

12258  
i = len - 1    = 4         8     f(4) = 1;  
i = len - 2     = 3        58    f(3) = 1;  
i = len - 3    = 2        258    =  2 58  | 25 8  == 2 f(i+1)  | 25 f(i+2)       ==>>    f(2)  = f(i+1) + f(i + 2);  
i = len -4    = 1       2258   = 2 258 | 22 58  = 2 f(i + 1) | 22 (i + 2)     ==>>     f(1) = f(i + 1) + f(i + 2)  



注意事项：
- int[n + 1] : 便于处理特殊情况的自减   




## 思路2
dp[i]代表s[:i]可以有几种解码方式

例：

s=        "1221"
index      0123


dp[0] = 1  [[1]]
dp[1] = 2  [[1,2], [12]]
  
判断 dp[i] 时，它有两种可能的组合方式：
1. 自身解码
    - 如果当前字符不是'0'，那么dp[i]的组合可以为dp[i-1]的所有组合方式后面都加上当前字符
    - 如果当前字符是'0'，那么dp[i]在这种情况下没有符合的组合方式
2. 和它前面的一个字符一起解码
    - 如果10 <= int(s[i-1:i+1]) <= 26, 那么dp[i]的组合可以为dp[i-2]的所有组合方式后面都加上s[i-1:i+1]
    - 如果int(s[i-1:i+1]) < 10 或者 int(s[i-1:i+1]) > 26，那么dp[i]在这种情况下没有符合的组合方式
    
dp[2] = 3  [[1,2,2], [12,2], [1,22]]
dp[3] = 5  [[1,2,2,1], [12,2,2], [1,22,2], [1,2,21], [12,21]]


注意 dp[0] 与 dp[1] 的处理，






当前遍历字符 [i] 是否有效  
- 有效: [i] != '0', 则 [i] 可以作为独立字符, 需要 dp[i-1] 的结果
- 无效: [i] = '0', 则 [i] 不可作为独立字符, 无法使用 dp[i-1] 的结果
[i-1, i] 是否有效
- 有效: 10<=[i-1,i]<=26, [i-1,i] 可作为独立字符, 需要 dp[i-2] 的结果
- 无效: !, [i-1,i] 不可作为独立字符, 无法使用 dp[i-2] 的结果


